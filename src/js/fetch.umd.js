!function (b, a) { "object" == typeof exports && "undefined" != typeof module ? a(exports) : "function" == typeof define && define.amd ? define(["exports"], a) : a(b.WHATWGFetch = {}) }(this, function (b) { "use strict"; var f = { searchParams: "URLSearchParams" in self, iterable: "Symbol" in self && "iterator" in Symbol, blob: "FileReader" in self && "Blob" in self && function () { try { return new Blob, !0 } catch (a) { return !1 } }(), formData: "FormData" in self, arrayBuffer: "ArrayBuffer" in self }; if (f.arrayBuffer) var h = ["[object Int8Array]", "[object Uint8Array]", "[object Uint8ClampedArray]", "[object Int16Array]", "[object Uint16Array]", "[object Int32Array]", "[object Uint32Array]", "[object Float32Array]", "[object Float64Array]"], i = ArrayBuffer.isView || function (a) { return a && h.indexOf(Object.prototype.toString.call(a)) > -1 }; function j(a) { if ("string" != typeof a && (a = String(a)), /[^a-z0-9\-#$%&'*+.^_`|~]/i.test(a)) throw new TypeError("Invalid character in header field name"); return a.toLowerCase() } function k(a) { return "string" != typeof a && (a = String(a)), a } function l(b) { var a = { next: function () { var a = b.shift(); return { done: void 0 === a, value: a } } }; return f.iterable && (a[Symbol.iterator] = function () { return a }), a } function a(b) { this.map = {}, b instanceof a ? b.forEach(function (a, b) { this.append(b, a) }, this) : Array.isArray(b) ? b.forEach(function (a) { this.append(a[0], a[1]) }, this) : b && Object.getOwnPropertyNames(b).forEach(function (a) { this.append(a, b[a]) }, this) } function m(a) { if (a.bodyUsed) return Promise.reject(new TypeError("Already read")); a.bodyUsed = !0 } function n(a) { return new Promise(function (b, c) { a.onload = function () { b(a.result) }, a.onerror = function () { c(a.error) } }) } function o(b) { var a = new FileReader, c = n(a); return a.readAsArrayBuffer(b), c } function p(a) { if (a.slice) return a.slice(0); var b = new Uint8Array(a.byteLength); return b.set(new Uint8Array(a)), b.buffer } function g() { return this.bodyUsed = !1, this._initBody = function (a) { if (this._bodyInit = a, a) { if ("string" == typeof a) this._bodyText = a; else if (f.blob && Blob.prototype.isPrototypeOf(a)) this._bodyBlob = a; else if (f.formData && FormData.prototype.isPrototypeOf(a)) this._bodyFormData = a; else if (f.searchParams && URLSearchParams.prototype.isPrototypeOf(a)) this._bodyText = a.toString(); else { var b; f.arrayBuffer && f.blob && (b = a) && DataView.prototype.isPrototypeOf(b) ? (this._bodyArrayBuffer = p(a.buffer), this._bodyInit = new Blob([this._bodyArrayBuffer])) : f.arrayBuffer && (ArrayBuffer.prototype.isPrototypeOf(a) || i(a)) ? this._bodyArrayBuffer = p(a) : this._bodyText = a = Object.prototype.toString.call(a) } } else this._bodyText = ""; !this.headers.get("content-type") && ("string" == typeof a ? this.headers.set("content-type", "text/plain;charset=UTF-8") : this._bodyBlob && this._bodyBlob.type ? this.headers.set("content-type", this._bodyBlob.type) : f.searchParams && URLSearchParams.prototype.isPrototypeOf(a) && this.headers.set("content-type", "application/x-www-form-urlencoded;charset=UTF-8")) }, f.blob && (this.blob = function () { var a = m(this); if (a) return a; if (this._bodyBlob) return Promise.resolve(this._bodyBlob); if (this._bodyArrayBuffer) return Promise.resolve(new Blob([this._bodyArrayBuffer])); if (!this._bodyFormData) return Promise.resolve(new Blob([this._bodyText])); throw new Error("could not read FormData body as blob") }, this.arrayBuffer = function () { return this._bodyArrayBuffer ? m(this) || Promise.resolve(this._bodyArrayBuffer) : this.blob().then(o) }), this.text = function () { var b, a, c, d = m(this); if (d) return d; if (this._bodyBlob) return b = this._bodyBlob, a = new FileReader, c = n(a), a.readAsText(b), c; if (this._bodyArrayBuffer) return Promise.resolve(function (d) { for (var b = new Uint8Array(d), c = new Array(b.length), a = 0; a < b.length; a++)c[a] = String.fromCharCode(b[a]); return c.join("") }(this._bodyArrayBuffer)); if (!this._bodyFormData) return Promise.resolve(this._bodyText); throw new Error("could not read FormData body as text") }, f.formData && (this.formData = function () { return this.text().then(r) }), this.json = function () { return this.text().then(JSON.parse) }, this } a.prototype.append = function (a, b) { a = j(a), b = k(b); var c = this.map[a]; this.map[a] = c ? c + ", " + b : b }, a.prototype.delete = function (a) { delete this.map[j(a)] }, a.prototype.get = function (a) { return a = j(a), this.has(a) ? this.map[a] : null }, a.prototype.has = function (a) { return this.map.hasOwnProperty(j(a)) }, a.prototype.set = function (a, b) { this.map[j(a)] = k(b) }, a.prototype.forEach = function (b, c) { for (var a in this.map) this.map.hasOwnProperty(a) && b.call(c, this.map[a], a, this) }, a.prototype.keys = function () { var a = []; return this.forEach(function (c, b) { a.push(b) }), l(a) }, a.prototype.values = function () { var a = []; return this.forEach(function (b) { a.push(b) }), l(a) }, a.prototype.entries = function () { var a = []; return this.forEach(function (b, c) { a.push([c, b]) }), l(a) }, f.iterable && (a.prototype[Symbol.iterator] = a.prototype.entries); var q = ["DELETE", "GET", "HEAD", "OPTIONS", "POST", "PUT"]; function d(b, c) { var g, f, e = (c = c || {}).body; if (b instanceof d) { if (b.bodyUsed) throw new TypeError("Already read"); this.url = b.url, this.credentials = b.credentials, c.headers || (this.headers = new a(b.headers)), this.method = b.method, this.mode = b.mode, this.signal = b.signal, e || null == b._bodyInit || (e = b._bodyInit, b.bodyUsed = !0) } else this.url = String(b); if (this.credentials = c.credentials || this.credentials || "same-origin", (c.headers || !this.headers) && (this.headers = new a(c.headers)), this.method = (f = (g = c.method || this.method || "GET").toUpperCase(), q.indexOf(f) > -1 ? f : g), this.mode = c.mode || this.mode || null, this.signal = c.signal || this.signal, this.referrer = null, ("GET" === this.method || "HEAD" === this.method) && e) throw new TypeError("Body not allowed for GET or HEAD requests"); this._initBody(e) } function r(a) { var b = new FormData; return a.trim().split("&").forEach(function (a) { if (a) { var c = a.split("="), d = c.shift().replace(/\+/g, " "), e = c.join("=").replace(/\+/g, " "); b.append(decodeURIComponent(d), decodeURIComponent(e)) } }), b } function c(c, b) { b || (b = {}), this.type = "default", this.status = void 0 === b.status ? 200 : b.status, this.ok = this.status >= 200 && this.status < 300, this.statusText = "statusText" in b ? b.statusText : "OK", this.headers = new a(b.headers), this.url = b.url || "", this._initBody(c) } d.prototype.clone = function () { return new d(this, { body: this._bodyInit }) }, g.call(d.prototype), g.call(c.prototype), c.prototype.clone = function () { return new c(this._bodyInit, { status: this.status, statusText: this.statusText, headers: new a(this.headers), url: this.url }) }, c.error = function () { var a = new c(null, { status: 0, statusText: "" }); return a.type = "error", a }; var s = [301, 302, 303, 307, 308]; c.redirect = function (b, a) { if (-1 === s.indexOf(a)) throw new RangeError("Invalid status code"); return new c(null, { status: a, headers: { location: b } }) }, b.DOMException = self.DOMException; try { new b.DOMException } catch (t) { b.DOMException = function (a, b) { this.message = a, this.name = b; var c = Error(a); this.stack = c.stack }, b.DOMException.prototype = Object.create(Error.prototype), b.DOMException.prototype.constructor = b.DOMException } function e(e, g) { return new Promise(function (l, j) { var h = new d(e, g); if (h.signal && h.signal.aborted) return j(new b.DOMException("Aborted", "AbortError")); var i = new XMLHttpRequest; function k() { i.abort() } i.onload = function () { var d, e, b = { status: i.status, statusText: i.statusText, headers: (d = i.getAllResponseHeaders() || "", e = new a, d.replace(/\r?\n[\t ]+/g, " ").split(/\r?\n/).forEach(function (c) { var a = c.split(":"), b = a.shift().trim(); if (b) { var d = a.join(":").trim(); e.append(b, d) } }), e) }; b.url = "responseURL" in i ? i.responseURL : b.headers.get("X-Request-URL"); var f = "response" in i ? i.response : i.responseText; l(new c(f, b)) }, i.onerror = function () { j(new TypeError("Network request failed")) }, i.ontimeout = function () { j(new TypeError("Network request failed")) }, i.onabort = function () { j(new b.DOMException("Aborted", "AbortError")) }, i.open(h.method, h.url, !0), "include" === h.credentials ? i.withCredentials = !0 : "omit" === h.credentials && (i.withCredentials = !1), "responseType" in i && f.blob && (i.responseType = "blob"), h.headers.forEach(function (a, b) { i.setRequestHeader(b, a) }), h.signal && (h.signal.addEventListener("abort", k), i.onreadystatechange = function () { 4 === i.readyState && h.signal.removeEventListener("abort", k) }), i.send(void 0 === h._bodyInit ? null : h._bodyInit) }) } e.polyfill = !0, self.fetch || (self.fetch = e, self.Headers = a, self.Request = d, self.Response = c), b.Headers = a, b.Request = d, b.Response = c, b.fetch = e, Object.defineProperty(b, "__esModule", { value: !0 }) })
